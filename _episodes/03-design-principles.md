---
# Please do not edit this file directly; it is auto generated.
# Instead, please edit 03-design-principles.md in _episodes_rmd/
title: "Experimental Design Principles"
teaching: 0
exercises: 0
questions:
- "What are the core principles of experimental design?"
objectives:
- "The way in which a design applies treatments to experimental units and measures the responses will determine 1) what questions can be answered and 2) with what precision relationships can be described."
- "The core principles guiding the way are 1) replication, 2) randomization and 3) blocking."
keypoints:
- "Replication, randomization and blocking determine the validity and usefulness of an experiment."
source: Rmd
---



Variability is natural in the real world. A medication given to a group of 
patients will affect each of them differently. A specific diet given to a cage
of mice will affect each mouse differently. Ideally if something is measured 
many times, each measurement will give exactly the same result and will 
represent the true value. This ideal doesn't exist in the real world. For 
example, the mass of one kilogram is defined by the International Prototype 
Kilogram, a cylinder composed of platinum and iridium. Copies of this prototype kilogram (replicates) are distributed worldwide and are regularly compared to 
the original to ensure the standard mass of one kilogram. None of the copies of 
the prototype measure precisely the same despite careful storage and handling. 
The reasons for this variation in measurements is not known.

## Replication
To figure out whether a difference in responses is real or inherently random, *replication* applies the same treatment to multiple experimental units. The
variability of the responses within a set of replicates provides a measure 
against which we can compare differences among different treatments. This 
variability is known as *experimental error*. This does not mean that something 
was done wrongly! It's a phrase describing the variability in the responses. 
Random variation is also known as *random error* or *noise*.  It reflects 
imprecision, but not inaccuracy. Larger sample sizes reduce this imprecision.

In addition to random (experimental) error, also known as noise, there are two
other sources of variability in experiments. *Systematic error* or bias, occurs 
when there are deviations in measurements or observations that are consistently 
in one particular direction, either overestimating or underestimating the true 
value. As an example, a scale might be calibrated so that mass measurements 
are consistently too high or too low. Unlike random error, systematic error is
consistent in one direction, is predictable and follows a pattern. Larger sample 
sizes don’t correct for systematic bias; equipment or measurement calibration 
does. *Technical replicates* define this systematic bias by running the same 
sample through the machine or measurement protocol multiple times to 
characterize the variation caused by equipment or protocols.

A *biological replicate* measures different biological samples in parallel to 
estimate the variation caused by the unique biology of the samples. The sample 
or group of samples are derived from the same biological source, such as cells, 
tissues, organisms, or individuals. Biological replicates assess the variability 
and reproducibility of experimental results. For example, if a study examines 
the effect of a drug on cell growth, biological replicates would involve 
multiple sets of cells from the same cell line to test the drug's effects. This 
helps to ensure that any observed changes are due to the drug itself rather than variations in the biological material being used. 

The greater the number of replications, the greater the precision (the closeness 
of two or more measurements to each other).  Having a large enough sample size 
to ensure high precision is necessary to ensure reproducible results.    

> ## Exercise 1: Which kind of error?
> A study used to determine the effect of a drug on weight loss 
> could have the following sources of experimental error. 
> Classify the following sources as either biological, 
> systematic, or random error.  
> 1). A scale is broken and provides inconsistent readings.  
> 2). A scale is calibrated wrongly and consistently measures mice 1 gram heavier.   
> 3). A mouse has an unusually high weight compared to its experimental group (i.e., it is an outlier).  
> 4). Strong atmospheric low pressure and accompanying storms affect instrument readings, animal behavior, and indoor relative humidity.  
>
> >
> > ## Solution to Exercise 1
> > 
> > 1). random, because the scale is broken and provides any kind of random reading it comes up with (inconsistent reading)  
> > 2). systematic  
> > 3). biological  
> > 4). random or systematic; you argue which and explain why
> > 
> {: .solution}
{: .challenge}

These three sources of error can be mitigated by good experimental design. 
Systematic and biological error can be mitigated through adequate numbers of 
technical and biological replicates, respectively. Random error can also be 
mitigated by experimental design, however, replicates are not effective. By 
definition random error is unpredictable or unknowable. For example, an 
atmospheric low pressure system or a strong storm could affect equipment 
measurements, animal behavior, and indoor relative humidity, which introduces 
random error. We could assume that all random error will balance itself out, and 
that all samples will be equally subject to random error. A more precise way to 
mitigate random error is through blocking. 

## Randomization

Why should treatments be randomly assigned to experimental units? Randomization
minimizes bias and moderates experimental error (a.k.a. noise). A hat full of 
numbers, a random number table or a computational random number generator can be 
used to assign random numbers to experimental units so that any experimental 
unit has equal chances of being assigned to a specific treatment group. 

Here is an example of randomization using a random number generator. The study
asks how a high-fat diet affects blood pressure in mice. If the number is odd, 
the sample is assigned to the treatment group, which receives the high-fat diet.
If the random number is even, the sample is assigned to the control group (the 
group that doesn't receive the treatment, in this case, regular chow). 


~~~
exp_unit <- LETTERS
random_number <- sample(x = 100, size = 26)

# %% is the modulo operator, which returns the remainder from division
treatment <- ifelse(random_number %% 2 == 0, "chow", "high fat")
random_allocation <- data.frame(exp_unit, random_number, treatment)
random_allocation
~~~
{: .language-r}



~~~
   exp_unit random_number treatment
1         A            90      chow
2         B            69  high fat
3         C            26      chow
4         D            25  high fat
5         E            30      chow
6         F            40      chow
7         G            29  high fat
8         H            42      chow
9         I            78      chow
10        J            63  high fat
11        K            71  high fat
12        L            16      chow
13        M            65  high fat
14        N            68      chow
15        O            47  high fat
16        P            32      chow
17        Q            91  high fat
18        R            62      chow
19        S            82      chow
20        T            98      chow
21        U            13  high fat
22        V            96      chow
23        W            23  high fat
24        X            95  high fat
25        Y            55  high fat
26        Z            88      chow
~~~
{: .output}

This might produce unequal numbers between treatment and control groups. It 
isn’t necessary to have equal numbers, however, *sensitivity* (the true positive 
rate, or ability to detect an effect when it truly exists) is maximized when 
sample numbers are equal.


~~~
table(random_allocation$treatment)
~~~
{: .language-r}



~~~

    chow high fat 
      14       12 
~~~
{: .output}

To randomly assign samples to groups with equal numbers, you can do the 
following.


~~~
# place IDs and random numbers in data frame
equal_allocation <- data.frame(exp_unit, random_number)

# sort by random numbers (not by sample IDs)
equal_allocation <- equal_allocation[order(random_number),]

# now assign to treatment or control groups
treatment <- sort(rep(x = c("chow", "high fat"), times = 13))
equal_allocation <- cbind(equal_allocation, treatment)
row.names(equal_allocation) <- 1:26
equal_allocation
~~~
{: .language-r}



~~~
   exp_unit random_number treatment
1         U            13      chow
2         L            16      chow
3         W            23      chow
4         D            25      chow
5         C            26      chow
6         G            29      chow
7         E            30      chow
8         P            32      chow
9         F            40      chow
10        H            42      chow
11        O            47      chow
12        Y            55      chow
13        R            62      chow
14        J            63  high fat
15        M            65  high fat
16        N            68  high fat
17        B            69  high fat
18        K            71  high fat
19        I            78  high fat
20        S            82  high fat
21        Z            88  high fat
22        A            90  high fat
23        Q            91  high fat
24        X            95  high fat
25        V            96  high fat
26        T            98  high fat
~~~
{: .output}

You can write out this treatment plan to a comma-separated values (csv) file,
then open it in Excel and use it to record your data collection or just keep
track of which samples are randomly assigned which diet.


~~~
write.csv(equal_allocation, file = "random-assign.csv", row.names = FALSE)
~~~
{: .language-r}
> ## Discussion
> Why not assign treatment and control groups to samples in alphabetical order?  
> Did we really need a random number generator to obtain randomized equal groups?
>
> >
> > ## Solution 
> > 
> > 1). Scenario: One technician processed samples A through M, and a different 
> > technician processed samples N through Z.  
> > 2). Another scenario: Samples A through M were processed on a Monday, and 
> > samples N through Z on a Tuesday.  
> > 3). Yet another scenario: Samples A through M were from one strain, and 
> > samples N through Z from a different strain.    
> > 4). Yet another scenario: Samples with consecutive ids were all sibling 
> > groups. For example, samples A, B and C were all siblings, and all assigned 
> > to the same treatment.  
> > All of these cases would have introduced an effect (from the technician, the 
> > day of the week, the strain, or sibling relationships) that would confound 
> > the results and lead to misinterpretation.
> > 
> {: .solution}
{: .challenge}

## Blocking
Experimental units can be grouped, or *blocked*, to increase the precision of
treatment comparisons. Imagine that you want to evaluate the effect of different 
doses of a new drug on the proliferation of cancer cells in vitro. Divide the 
cells into four groups, each consisting of the same number of cells. Treat each 
group with a different dose of the drug for five consecutive days. For example, 
the four treatments could be:

Group 1: Control (no drug)
Group 2: Low dose (10 μM)
Group 3: Medium dose (50 μM)
Group 4: High dose (100 μM)


~~~
# create dosage levels
f <- factor(c("control", "low", "medium", "high"))
b1t <- sample(f, 4)
b2t <- sample(f, 4)
b3t <- sample(f, 4)
b4t <- sample(f, 4)
t <- c(b1t, b2t, b3t, b4t)
block <- factor(rep(c("shelf1", "shelf2", "shelf3", "shelf4"), each = 4))
cagenum <- rep(1:4, 4)
plan <- data.frame(block = block, CageNumber = cagenum, treatment = t)
plan
~~~
{: .language-r}



~~~
    block CageNumber treatment
1  shelf1          1    medium
2  shelf1          2       low
3  shelf1          3      high
4  shelf1          4   control
5  shelf2          1      high
6  shelf2          2       low
7  shelf2          3   control
8  shelf2          4    medium
9  shelf3          1   control
10 shelf3          2      high
11 shelf3          3       low
12 shelf3          4    medium
13 shelf4          1    medium
14 shelf4          2       low
15 shelf4          3      high
16 shelf4          4   control
~~~
{: .output}
{% include links.md %}
